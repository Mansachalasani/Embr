import { GoogleGenerativeAI } from '@google/generative-ai';
import { AIToolMetadata, AIToolSelection, AIResponse, UserContext } from '../types/aiTools';
import { MCPToolRegistry } from './mcpToolRegistry';
import { SessionService } from './sessionService';

export class AIService {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private toolRegistry: MCPToolRegistry;
  private responseCache: Map<string, any> = new Map();
  private cacheTimeout = 5 * 60 * 1000; // 5 minutes

  constructor() {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY environment variable is required');
    }
    
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
    this.toolRegistry = MCPToolRegistry.getInstance();
  }

  /**
   * Main AI reasoning pipeline
   */
  async processQuery(context: UserContext, userId: string): Promise<AIResponse> {
    try {
      console.log('üß† AI Processing query:', context.query);
      
      // Step 1: Analyze query and select tool
      const toolSelection = await this.selectTool(context, userId);
      
      console.log(toolSelection)
      if (!toolSelection) {
        return {
          success: false,
          naturalResponse: "I'm not sure how to help with that request. I can assist with calendar events, emails, and productivity tasks.",
          error: 'No suitable tool found'
        };
      }

      if(toolSelection && toolSelection.tool === null && toolSelection.geminiOutput){
        return {
          success: true,
          naturalResponse: toolSelection.geminiOutput,
          reasoning: toolSelection.reasoning,
          rawData: null,
          suggestedActions: []
        };
      }
      console.log('üéØ Selected tool:', toolSelection.tool, 'with confidence:', toolSelection.confidence);
      
      // Step 2: Execute the selected tool
      const toolResult = await this.executeTool(toolSelection, userId);
      
      // Step 2.5: Check if we need tool chaining
      let chainedResult = null;
      if (toolResult.success && this.shouldChainTool(toolSelection, toolResult, context)) {
        chainedResult = await this.performToolChaining(toolSelection, toolResult, userId, context);
      }
      
      // Step 3: Generate natural language response
      const finalResult = chainedResult || toolResult;
      const naturalResponse = await this.generateResponse(context, toolSelection, finalResult, userId);
      
      return {
        success: true,
        toolUsed: toolSelection.tool,
        rawData: finalResult.data,
        naturalResponse,
        reasoning: toolSelection.reasoning,
        suggestedActions: await this.generateSuggestedActions(context, finalResult),
        chainedTools: chainedResult ? ['searchWeb', 'crawlPage'] : undefined
      };

    } catch (error) {
      console.error('‚ùå AI processing error:', error);
      return {
        success: false,
        naturalResponse: 'Sorry, I encountered an error while processing your request. Please try again.',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Analyze user query and select the best tool with conversation context
   */
  public async selectTool(context: UserContext, userId?: string): Promise<AIToolSelection | null> {
    const availableTools = this.toolRegistry.getAllToolMetadata();
    
//     const prompt = `
// You are an intelligent assistant that helps users with calendar, email, and productivity tasks.

// Available Tools:
// ${this.formatToolsForPrompt(availableTools)}

// User Query: "${context.query}"
// Timestamp: ${context.timestamp}

// Analyze the user's query and determine:
// 1. Which tool (if any) best matches their request
// 2. What parameters should be passed to that tool
// 3. Your confidence level (0-100)
// 4. Your reasoning

// Respond in JSON format:
// {
//   "tool": "toolName or null",
//   "confidence": 85,
//   "parameters": {},
//   "reasoning": "explanation of your choice",
//   "geminiOutput": "optional output if no tool is needed"
// }

// Guidelines:
// - Calendar queries: use getTodaysEvents for "today", "this morning", "afternoon", "meetings"
// - Email queries: use getEmails for "emails", "messages", "inbox", "mail" - supports advanced search
// - If the query is unclear or doesn't match any tool, return tool: null
// - If the output can be generated by gemini and  dosent require a tool, return tool:null and add geminiOutput:{the output which can be showed to the user}
// - Be precise with parameters - only include what the user specified
// `;

    // Get conversation context if sessionId is provided
    let conversationContext = '';
    if (context.sessionId && userId) {
      try {
        const contextData = await SessionService.getConversationContext(context.sessionId, userId, 5);
        if (contextData.messages.length > 0) {
          conversationContext = '\n\nConversation History (last 5 messages):\n' + 
            contextData.messages.map(msg => `${msg.role}: ${msg.content}`).join('\n');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not fetch conversation context:', error);
      }
    }

const prompt=`You are an intelligent assistant that decides whether to use a tool or directly answer with Gemini.

Available Tools:
${this.formatToolsForPrompt(availableTools)}

User Query: "${context.query}"
Timestamp: ${context.timestamp}${conversationContext}

Your task:
1. Decide if the query should be handled by a tool or directly answered by Gemini.
2. If a tool is best, pick the correct one and extract the required parameters.
3. For real-time data (weather, news, stock prices, movie times, etc.) ALWAYS use searchWeb first.
4. If the user mentions or asks about a specific website/URL, use crawlPage to get current content.
5. If no tool matches but Gemini can generate a useful answer, provide that as "geminiOutput".
6. Always classify the response into a category (e.g., "calendar", "email", "weather", "search", "general").
7. Indicate if Gemini's output can safely be shown to the user with a boolean flag.

Respond in **valid JSON**:
{
  "tool": "toolName or null",
  "confidence": 0-100,
  "parameters": { "only include parameters explicitly mentioned by user" },
  "reasoning": "why this choice was made",
  "geminiOutput": "text or null",
  "category": "general | weather | email | calendar | search | ...",
  "canUseGemini": true/false
}

Guidelines:
- Use conversation history to understand context and follow-up questions.
- Use a tool when the user explicitly asks for actions related to the tool's functionality.
- Calendar queries: use getTodaysEvents for "today", "this morning", "afternoon", "meetings"
- Email queries: use getEmails for "emails", "messages", "inbox", "mail" - supports advanced search, date filtering, labels, attachments
- For email queries, leverage Gmail search syntax (from:, subject:, is:unread, has:attachment, after:, before:, etc.)
- **Real-time data queries**: Use searchWeb for weather, news, stock prices, movie showtimes, restaurant info, traffic, sports scores, etc.
- **URL/Website queries**: Use crawlPage when user provides a URL or asks about specific website content
- **Current events**: Use searchWeb for "latest", "recent", "today's", "breaking news", etc.
- Consider previous messages when interpreting pronouns and references (e.g., "what about tomorrow?" after discussing today's calendar).
- If unclear, return "tool": null and "geminiOutput": null.
`

    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      let text = response.text().trim();

      // Sanitize for safety
      if (text.startsWith("```")) {
        text = text.replace(/```(json)?/g, "").trim();
      }
    
      
      console.log('ü§ñ AI tool selection response:', text);
      
      const selection = JSON.parse(text);
      console.log(selection)
      
      // // Validate selection
      // if (selection.tool && !availableTools.find(t => t.name === selection.tool)) {
      //   console.warn('‚ö†Ô∏è AI selected invalid tool:', selection.tool);
      //   return null;
      // }
      
      // return selection.tool ? selection : null;
      return selection
      
    } catch (error) {
      console.error('‚ùå Error in tool selection:', error);
      return null;
    }
  }

  /**
   * Execute the selected MCP tool with caching
   */
  public async executeTool(selection: AIToolSelection, userId: string): Promise<any> {
    const tool = this.toolRegistry.getTool(selection.tool);
    if (!tool) {
      throw new Error(`Tool ${selection.tool} not found`);
    }

    // Create cache key
    const cacheKey = `${selection.tool}_${userId}_${JSON.stringify(selection.parameters)}`;
    
    // Check cache for non-real-time tools
    const cachedData = this.responseCache.get(cacheKey);
    if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {
      console.log('üìã Using cached result for tool:', selection.tool);
      return cachedData.result;
    }

    console.log('üîß Executing tool:', selection.tool, 'with params:', selection.parameters);
    
    const result = await tool.execute(userId, selection.parameters);
    
    // Cache the result
    this.responseCache.set(cacheKey, {
      result,
      timestamp: Date.now()
    });
    
    // Clean old cache entries periodically
    if (this.responseCache.size > 100) {
      this.cleanCache();
    }
    
    return result;
  }

  /**
   * Clean expired cache entries
   */
  private cleanCache(): void {
    const now = Date.now();
    for (const [key, value] of this.responseCache.entries()) {
      if (now - value.timestamp > this.cacheTimeout) {
        this.responseCache.delete(key);
      }
    }
  }

  /**
   * Generate natural language response from tool result with conversation context
   */
  public async generateResponse(context: UserContext, selection: AIToolSelection, toolResult: any, userId?: string): Promise<string> {
    if (!toolResult.success) {
      return `I couldn't retrieve the information you requested. ${toolResult.error || 'Please try again later.'}`;
    }

    // Get conversation context if sessionId is provided
    let conversationContext = '';
    if (context.sessionId && userId) {
      try {
        const contextData = await SessionService.getConversationContext(context.sessionId, userId, 3);
        if (contextData.messages.length > 0) {
          conversationContext = '\n\nConversation History (last 3 messages):\n' + 
            contextData.messages.map(msg => `${msg.role}: ${msg.content.substring(0, 100)}${msg.content.length > 100 ? '...' : ''}`).join('\n');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not fetch conversation context for response generation:', error);
      }
    }

    const prompt = `
You are a helpful personal assistant. Convert this raw data into a natural, conversational response.

Original Query: "${context.query}"
Tool Used: ${selection.tool}
Raw Data: ${JSON.stringify(toolResult.data, null, 2)}${conversationContext}

Instructions:
- Write in a friendly, conversational tone
- Use conversation history to maintain context and continuity
- Focus on what the user asked for specifically
- If it's calendar data, mention times and key details
- If it's email data, summarize key messages
- Keep it concise but informative
- Use emojis sparingly and appropriately
- If the data is empty or minimal, acknowledge that naturally
- Reference previous messages when relevant (e.g., "As I mentioned earlier...")

Examples:
- For calendar: "You have 3 meetings today. Your next one is the team standup at 10 AM."
- For email: "You have 5 new emails. The most recent is from John about the project deadline."

Generate a natural response:
`;

    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      return response.text().trim();
    } catch (error) {
      console.error('‚ùå Error generating response:', error);
      return 'I found the information you requested, but had trouble formatting the response. Please check the raw data above.';
    }
  }

  /**
   * Generate suggested follow-up actions
   */
  public async generateSuggestedActions(context: UserContext, toolResult: any): Promise<string[]> {
    // Simple rule-based suggestions for now
    const suggestions: string[] = [];
    
    if (context.query.toLowerCase().includes('calendar') || context.query.toLowerCase().includes('meeting')) {
      suggestions.push('Would you like to see your schedule for tomorrow?');
      suggestions.push('Do you want to check for any conflicts?');
    }
    
    if (context.query.toLowerCase().includes('email')) {
      suggestions.push('Would you like me to check for any urgent emails?');
      suggestions.push('Do you want to see emails from specific people?');
    }
    
    return suggestions.slice(0, 2); // Limit to 2 suggestions
  }

  /**
   * Determine if we should chain to another tool based on the first tool's result
   */
  private shouldChainTool(selection: AIToolSelection, toolResult: any, context: UserContext): boolean {
    if (!toolResult.success || !toolResult.data) return false;
    
    // If we used searchWeb and got URLs that might be relevant, consider crawling them
    if (selection.tool === 'searchWeb' && toolResult.data.results) {
      const results = toolResult.data.results;
      // Check if query suggests user wants detailed content analysis
      const wantsSummary = context.query.toLowerCase().includes('summarize') ||
                          context.query.toLowerCase().includes('analyze') ||
                          context.query.toLowerCase().includes('what does') ||
                          context.query.toLowerCase().includes('content of');
      
      // If we have results and user wants detailed analysis, chain to crawlPage
      return wantsSummary && results.length > 0;
    }
    
    return false;
  }
  
  /**
   * Perform tool chaining - automatically use a second tool based on first tool's results
   */
  private async performToolChaining(
    firstSelection: AIToolSelection, 
    firstResult: any, 
    userId: string, 
    context: UserContext
  ): Promise<any> {
    try {
      console.log('üîó Performing tool chaining after:', firstSelection.tool);
      
      if (firstSelection.tool === 'searchWeb' && firstResult.data.results) {
        // Get the most relevant URL from search results
        const topResult = firstResult.data.results[0];
        if (topResult && topResult.url) {
          console.log('üîó Chaining to crawlPage for URL:', topResult.url);
          
          // Use crawlPage to get detailed content
          const crawlTool = this.toolRegistry.getTool('crawlPage');
          if (crawlTool) {
            const crawlResult = await crawlTool.execute(userId, {
              url: topResult.url,
              extract_content: true,
              max_length: 3000
            });
            
            if (crawlResult.success) {
              // Combine search results with crawled content
              return {
                success: true,
                data: {
                  search_results: firstResult.data,
                  crawled_content: crawlResult.data,
                  chained_tools: ['searchWeb', 'crawlPage']
                }
              };
            }
          }
        }
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå Error in tool chaining:', error);
      return null;
    }
  }

  /**
   * Format available tools for the AI prompt
   */
  private formatToolsForPrompt(tools: AIToolMetadata[]): string {
    return tools.map(tool => `
Tool: ${tool.name}
Description: ${tool.description}
Category: ${tool.category}
Parameters: ${tool.parameters.map(p => `${p.name} (${p.type}${p.required ? ', required' : ''}): ${p.description}`).join(', ')}
Examples: ${tool.examples.map(e => `"${e.query}"`).join(', ')}
`).join('\n');
  }
}